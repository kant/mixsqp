---
title: "Illustration of mix-SQP solver applied to a small data set, and a large one"
author: "Youngseok Kim and Peter Carbonetto"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_document:
    theme: readable
    before_body: header.html
    after_body: footer.html
vignette: >
  %\VignetteIndexEntry{mixsqp-intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE,results = "hold",comment = "#",
                      fig.width = 5,fig.height = 3,fig.align = "center",
                      fig.cap = "&nbsp;",dpi = 120)
```

In this vignette, we compare the runtime and accuracy of the SQP
algorithm against an interior-point (IP) solver implemented by the
[MOSEK][mosek] commercial software, and called by the "KWDual"
function in the [REBayes package][rebayes].

## Environment set-up

We begin by loading the mixsqp and Rmosek packages. (The Rmosek
package is only used to check the version of MOSEK.)

```{r load-pkgs, message=FALSE}
library(mixsqp)
library(Rmosek)
```

Next, initialize the sequence of pseudorandom numbers.

```{r set-seed}
set.seed(1)
```

## Generate a small data set

We begin with a small example to show how the SQP method works.

```{r sim-data-small}
L <- simulatemixdata(1000,20)$L
dim(L)
```

This call to `simulatemixdata` created an $n \times k$ conditional
likelihood matrix for a mixture of zero-centered normals, with $m =
20$. By default, `simulatemixdata` normalizes the rows of the
likelihood matrix so that the maximum entry in each row is 1.

## Fit mixture model

Now we fit the mixture model using the SQP solver:

```{r fit-model-mixsqp-small}
fit.sqp <- mixsqp(L)
```

In this example, the SQP solver converged to a solution in a small
number of iterations.

By default, `mixsqp` gives information on its progress toward the
solution. First, it summarizes the optimization problem, and the
algorithm settings being used.

After that, it outputs, at each iteration, information about the
current solution such as the value of the objective and the number of
nonzeros ("nnz").

To monitor convergence toward the solution, the most important column
is "max(rdual)", which gives the maximum value of the "dual residual",
which is the exact quantity used to determine when to stop the
algorithm; the SQP solver terminates when the maximum dual residual is
less than `conv.tol`, which by default is $10^{-8}$. In this example,
the dual residual shinks rapidly toward zero.

Another useful indicator of convergence to the solution is the
"max.diff" column---it reports the maximum difference between the
estimates at two successive iterations, and we expect these
differences to shrink as we approach the solution, as we see here in
this example.

To assess the accuracy of the SQP solution, let's compare against the
IP solver:

```{r fit-model-kwdual-small}
fit.ip <- mixkwdual(L)
```

The IP and SQP solutions are very similar for this small example:

```{r compare-solutions-smaller}
cat(sprintf("Objective at SQP solution: %0.16f\n",fit.sqp$value,digits = 16))
cat(sprintf("Objective at IP solution:  %0.16f\n",fit.ip$value,digits = 16))
cat(sprintf("Difference in objectives:  %0.4e\n",fit.sqp$value - fit.ip$value))
```

## Comparison using a larger data set

Next, let's see what happens when we apply the IP and SQP methods
algorithms to a considerably larger data set.

As before, we compute the $n \times m$ likelihood matrix for a mixture
of zero-centered normals. This time, we use a finer grid of $m = 50$
normal densities, as well as more samples.

```{r sim-data-larger}
L <- simulatemixdata(1e5,50)$L
dim(L)
```

Now we fit the model using the two fitting algorithms.

```{r fit-model-larger}
timing.ip  <- system.time(fit.ip  <- mixkwdual(L))
timing.sqp <- system.time(fit.sqp <- mixsqp(L))
```

The mix-SQP algorithm is noticeably faster than the IP solver.

```{r timing-fit-larger}
cat(sprintf("Runtime of IP solver:  %0.2f\n",timing.ip["elapsed"]))
cat(sprintf("Runtime of SQP solver: %0.2f\n",timing.sqp["elapsed"]))
```

Further, the quality of the IP and SQP solutions remains very similar:

```{r compare-solutions-larger}
cat(sprintf("Objective at SQP solution: %0.16f\n",fit.sqp$value,digits = 16))
cat(sprintf("Objective at IP solution:  %0.16f\n",fit.ip$value,digits = 16))
cat(sprintf("Difference in objectives:  %0.4e\n",fit.sqp$value - fit.ip$value))
```

## Session information

This next code chunk gives information about the computing environment
used to generate the results contained in this vignette, including the
version of R and the packages used.

```{r session-info}
sessionInfo()
```

Since we used Rmosek, it is also helpful to record the version of
MOSEK that was used.

```{r mosek-info}
mosek_version()
```

[mosek]: https://www.mosek.com
[rebayes]: https://cran.r-project.org/package=REBayes
