---
title: "Illustration of mix-SQP solver applied to a small data set, and a large one"
author: "Youngseok Kim and Peter Carbonetto"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_document:
    theme: readable
    before_body: header.html
    after_body: footer.html
vignette: >
  %\VignetteIndexEntry{mixSQP-intro}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE,results = "hold",comment = "#",
                      fig.width = 5,fig.height = 3,fig.align = "center",
                      fig.cap = "&nbsp;",dpi = 120)
```

In this vignette, we compare the runtime and accuracy of the mix-SQP
algorithm against an interior-point (IP) solver implemented by the
[MOSEK][mosek] commercial software, and called via the "KWDual"
function in the [REBayes package][rebayes].

## Environment set-up

We begin by loading the mixSQP and Rmosek packages. (The Rmosek
package is only needed to check the version of MOSEK solver being
used.)

```{r load-pkgs, message=FALSE}
library(mixSQP)
library(Rmosek)
```

Next, initialize the sequence of pseudorandom numbers.

```{r set-seed}
set.seed(1)
```

## Generate a small data set

Let's begin with a smaller example with $n=$ 50,000 samples.

```{r sim-data-small}
L <- simulatemixdata(5e4,10)$L
dim(L)
```

This call to `simulatemixdata` created an $n \times k$ conditional
likelihood matrix for a mixture of zero-centered normals, with $m =
10$. Note that the rows of the likelihood matrix are normalized by
default so that the maximum entry in each row is 1.

[mosek]: https://www.mosek.com
[rebayes]: https://cran.r-project.org/package=REBayes

## Fit mixture model

First, we fit the mixture model using the mix-SQP solver.

```{r fit-model-mixsqp-small}
timing.sqp <- system.time(fit.sqp <- mixSQP(L))
cat(sprintf("Computation took %0.2f seconds.\n",timing.sqp["elapsed"]))
```

Next, we fit the same mixture model using the IP solver.

```{r fit-model-kwdual-small}
timing.ip <- system.time(fit.ip <- mixKWDual(L))
cat(sprintf("Computation took %0.2f seconds.\n",timing.ip["elapsed"]))
```

The runtime of the mix-SQP algorithm is less than the IP method, and
the quality of the IP and SQP solutions is very similar.

```{r compare-solutions-small}
cat(sprintf("Objective at SQP solution: %0.16f\n",fit.sqp$value,digits = 16))
cat(sprintf("Objective at IP solution:  %0.16f\n",fit.ip$value,digits = 16))
cat(sprintf("Difference in objectives:  %0.4e\n",fit.sqp$value - fit.ip$value))
```

## Comparison using a large data set

Next, let's see what happens when we apply the IP and SQP methods
algorithms to a considerably larger data set.

As before, we compute the $n \times m$ likelihood matrix for a mixture
of zero-centered normals. This time, we use a finer grid of $m = 50$
normal densities, as well as more samples.

```{r sim-data-large}
L <- simulatemixdata(1e5,50)$L
dim(L)
```

Now we fit the model using the two fitting algorithms.

```{r fit-model-large}
timing.ip  <- system.time(fit.ip  <- mixKWDual(L))
timing.sqp <- system.time(fit.sqp <- mixSQP(L))
```

The mix-SQP algorithm algorithm is again faster than the IP solver.

```{r timing-fit-large}
cat(sprintf("Runtime of IP solver:  %0.2f\n",timing.ip["elapsed"]))
cat(sprintf("Runtime of SQP solver: %0.2f\n",timing.sqp["elapsed"]))
```

Further, the quality of the IP and SQP solutions remains very similar:

```{r compare-solutions-large}
cat(sprintf("Objective at SQP solution: %0.16f\n",fit.sqp$value,digits = 16))
cat(sprintf("Objective at IP solution:  %0.16f\n",fit.ip$value,digits = 16))
cat(sprintf("Difference in objectives:  %0.4e\n",fit.sqp$value - fit.ip$value))
```

## Session information

This next code chunk gives information about the computing environment
used to generate the results contained in this vignette, including the
version of R and the packages used.

```{r session-info}
sessionInfo()
```

Since we used Rmosek, it is also helpful to record the version of
MOSEK that was used.

```{r mosek-info}
mosek_version()
```
