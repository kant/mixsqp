<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Maximum-likelihood estimation of mixture proportions using SQP — mixsqp • mixsqp</title>

<!-- jquery -->
<script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script>
<script src="../pkgdown.js"></script>
  
  
<meta property="og:title" content="Maximum-likelihood estimation of mixture proportions using SQP — mixsqp" />

<meta property="og:description" content="The mixsqp function uses a Sequential Quadratic
Programming (SQP) algorithm to find the maximum likelihood
estimates of mixture proportions in a (finite) mixture model. More
generally, mixsqp solves the corresponding constrained,
convex optimization problem, which is given below (see
&#8216;Details&#8217;). See &#8216;References&#8217; for more details about
the SQP algorithm." />
<meta name="twitter:card" content="summary" />
<!-- mathjax -->
<script src='https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->


  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">mixsqp</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">Home</a>
</li>
<li>
  <a href="../articles/index.html">Vignettes</a>
</li>
<li>
  <a href="../reference/index.html">Functions</a>
</li>
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/stephenslab/mixsqp">Source</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      
      </header>

      <div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Maximum-likelihood estimation of mixture proportions using SQP</h1>
    </div>

    
    <p>The <code>mixsqp</code> function uses a Sequential Quadratic
Programming (SQP) algorithm to find the maximum likelihood
estimates of mixture proportions in a (finite) mixture model. More
generally, <code>mixsqp</code> solves the corresponding constrained,
convex optimization problem, which is given below (see
&#8216;Details&#8217;). See &#8216;References&#8217; for more details about
the SQP algorithm.</p>
    

    <pre class="usage"><span class='fu'>mixsqp</span>(<span class='no'>L</span>, <span class='kw'>w</span> <span class='kw'>=</span> <span class='fu'>rep</span>(<span class='fl'>1</span>, <span class='fu'>nrow</span>(<span class='no'>L</span>)), <span class='kw'>x0</span> <span class='kw'>=</span> <span class='fu'>rep</span>(<span class='fl'>1</span>, <span class='fu'>ncol</span>(<span class='no'>L</span>)),
  <span class='kw'>control</span> <span class='kw'>=</span> <span class='fu'>list</span>())

<span class='fu'>mixsqp_control_default</span>()</pre>
    
    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a> Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>L</th>
      <td><p>Matrix specifying the optimization problem to be solved.
In the context of mixture-model fitting, <code>L[j,k]</code> should be
the value of the kth mixture component density at the jth data
point. <code>L</code> should be a numeric matrix with at least two
columns, with all entries being non-negative and finite (and not
missing). Further, no column should be entirely zeros. For large
matrices, it is preferrable that the matrix is stored in
double-precision; see <code>storage.mode</code>.</p></td>
    </tr>
    <tr>
      <th>w</th>
      <td><p>An optional numeric vector, with one entry for each row of
<code>L</code>, specifying the "weights" associated with the rows of
<code>L</code>. All weights must be finite, non-negative and not
missing. Internally, the weights are normalized to sum to 1,
which does not change the problem, but does change the value of the
objective function reported. By default, all weights are equal.</p></td>
    </tr>
    <tr>
      <th>x0</th>
      <td><p>An optional numeric vector providing an initial estimate
of the solution to the optimization problem. It should contain only
finite, non-missing, non-negative values, and all entries of
<code>L %*% x0</code> must be greater than zero (to ensure that the
objective evaluates to a finite value at <code>x0</code>). The vector
will be normalized to sum to 1. By default, <code>x0</code> is the vector
with all equal values.</p></td>
    </tr>
    <tr>
      <th>control</th>
      <td><p>A list of parameters controlling the behaviour of
the optimization algorithm. See &#8216;Details&#8217;.</p></td>
    </tr>
    </table>
    
    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>A list object with the following elements:</p>
<dt>x</dt><dd><p>The solution to the convex optimization problem.</p></dd>

<dt>value</dt><dd><p>The value of the objective function, \(f(x)\), at
<code>x</code>.</p></dd>

<dt>status</dt><dd><p>A character string giving the status of the algorithm
upon termination.</p></dd>

<dt>progress</dt><dd><p>A data frame containing more detailed information
about the algorithm's progress. The data frame has one row per SQP
iteration. For an explanation of the columns, see the description
of the <code>verbose</code> control paramter in &#8216;Details&#8217;. Missing
values (<code>NA</code>'s) in the last row indicate that these quantities were
not computed because convergence was reached before computing
them. Also note that the storage of these quantities in the
<code>progress</code> data frame is slightly different than in the console
output (when <code>verbose = TRUE</code>) as the console output shows some
quantities that were computed after the convergence check in the
previous iteration.</p></dd>

    
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p><code>mixsqp</code> solves the following optimization problem.
Let \(L\) be a matrix with \(n\) rows and \(m\) columns
containing only non-negative entries, and let \(w = (w_1,
\ldots, w_n)\) be a vector of non-negative "weights". <code>mixsqp</code>
computes the value of vector \(x = (x_1, \ldots, x_m)\)
minimizing the following objective function,
$$f(x) = -\sum_{j=1}^n w_j \log (\sum_{k=1}^m L_{jk} x_k),$$
subject to the constraint that \(x\) lie within the simplex;
that is, the entries of \(x\) are non-negative and sum to 1.
Implicitly, there is an additional constraint \(L*x &gt; 0\) in
order to ensure that the objective has a finite value. In practice,
this constraint only needs to be checked for the initial estimate
to ensure that it holds for all subsequent iterates.</p>
<p>If all weights are equal, solving this optimization problem
corresponds to finding the maximum-likelihood estimate of the
mixture proportions \(x\) given \(n\) independent data points
drawn from a mixture model with \(m\) components. In this case,
\(L_{jk}\) is the likelihood for mixture component \(k\) and
data point \(j\).</p>
<p>The Expectation Maximization (EM) algorithm can be used to solve
this optimization problem, but it is intolerably slow in many
interesting cases, and mixsqp is much faster.</p>
<p>A special feature of this optimization problem is that the gradient
of the objective does not change with re-scaling; for example, if
all the entries of matrix <code>L</code> are multiplied by 100, the
gradient does not change. A practical benefit of this property is
that the optimization algorithm will behave similarly irrespective
of the scale of <code>L</code>; for example, the same value for the
convergence tolerance <code>convtol.sqp</code> will have the same effect
at different scales. The one exception is the <code>eps</code> control
parameter, which should be adjusted appropriately to reflect the
scale of <code>L</code>, or set to zero; see the description of this
parameter below for more details.</p>
<p>A related feature is that the solution to the optimization problem
is invariant to rescaling the rows of <code>L</code>; for example, the
solution will remain the same after all the entries in a row of
<code>L</code> are multiplied by 10. A simple normalization scheme
divides each row by the largest entry in the row so that all
entries of <code>L</code> are at most 1: <code>L &lt;- L / apply(L,1,max)</code>
Occasionally, it can be helpful to normalize the rows when some of
the entries are unusually large or unusually small. This can help
to avoid numerical overflow or underflow errors.</p>
<p>The SQP algorithm is implemented using the Armadillo C++ linear
algebra library, which can automatically take advantage of
multithreaded matrix computations to speed up <code>mixsqp</code> for
large <code>L</code> matrices, but only when R has been configured with a
multithreaded BLAS/LAPACK library (e.g., OpenBLAS).</p>
<p>The <code>control</code> argument is a list in which any of the
following named components will override the default optimization
algorithm settings (as they are defined by
<code>mixsqp_control_defaults</code>):</p><dl class='dl-horizontal'>
    <dt><code>convtol.sqp</code></dt><dd><p>A small, non-negative number
specifying the convergence tolerance for SQP algorithm; convergence
is reached when the maximum dual residual in the Karush-Kuhn-Tucker
(KKT) optimality conditions is less than or equal to
<code>convtol.sqp</code>. Smaller values will result in more stringent
convergence criteria and more accurate solutions, at the expense of
greater computation time. Note that changes to this tolerance
parameter may require respective changes to
<code>convtol.activeset</code> and/or <code>zero.threshold.searchdir</code> to
obtain reliable convergence.</p></dd>
    <dt><code>convtol.activeset</code></dt><dd><p>A small, non-negative number
specifying the convergence tolerance for the active-set
step. Smaller values will result in higher quality search
directions for the SQP algorithm but possibly a greater
per-iteration computational cost. Note that changes to this
tolerance parameter can affect how reliably the SQP convergence
criterion is satisfied, as determined by <code>convtol.sqp</code>.</p></dd>
    <dt><code>zero.threshold.solution</code></dt><dd><p>A small, non-negative
number used to determine the "active set"; that is, it determines
which entries of the solution are exactly zero. Any entries that
are less than or equal to <code>zero.threshold.solution</code> are
considered to be exactly zero. Larger values of
<code>zero.threshold.solution</code> may lead to speedups for matrices
with many columns, at the (slight) risk of prematurely zeroing some
co-ordinates.</p></dd>
    <dt><code>zero.threshold.searchdir</code></dt><dd><p>A small, non-negative
number used to determine when the search direction in the
active-set step is considered "small enough". Note that changes to
this tolerance parameter can affect how reliably the SQP
convergence criterion is satisfied, as determined by
<code>convtol.sqp</code>, so choose this parameter carefully.</p></dd>
    <dt><code>eps</code></dt><dd><p>A small, non-negative number added to the
terms inside the logarithms to sidestep computing logarithms of
zero. This prevents numerical problems at the cost of introducing a
small inaccuracy in the solution. Increasing this number may lead
to faster convergence but possibly a less accurate solution. Note
that an appropriate value of <code>eps</code> will depend on the "scale"
of <code>L</code>; for example, if the largest entry in the matrix is
<code>1e-10</code>, setting <code>eps = 1e-8</code> will dominate the
logarithm terms in the objective, leading to inaccurate solutions.
In such situations, <code>eps</code> should be increased or decreased
appropriately (or set to zero), or the rows of <code>L</code> can
normalized beforehand (see above).</p></dd>
    <dt><code>delta</code></dt><dd><p>A small, non-negative number added to the
diagonal of the Hessian to improve numerical stability (and
possibly the speed) when computing the search directions in the
active-set step.</p></dd>
    <dt><code>maxiter.sqp</code></dt><dd><p>Maximum number of SQP iterations to
run before reporting a convergence failure; that is, the maximum
number of quadratic subproblems that will be solved by the
active-set method.</p></dd>
    <dt><code>maxiter.activeset</code></dt><dd><p>Maximum number of active-set
iterations taken to solve each of the quadratic subproblems.</p></dd>
    <dt><code>verbose</code></dt><dd><p>If <code>verbose = TRUE</code>, the algorithm's
progress and a summary of the optimization settings are printed to
the console. The algorithm's progress is displayed in a table with
one row per SQP (outer loop) iteration, and with the following
columns: "iter", the (outer loop) SQP iteration; "objective", the
value of the objective function (see \(f(x)\)) at the current
estimate of the solution, \(x\); "max(rdual)", the maximum "dual
residual" in the Karush-Kuhn-Tucker (KKT) conditions, which is used
to monitor convergence (see <code>convtol.sqp</code>); "nnz", the number
of non-zero co-ordinates in the current estimate, as determined by
<code>zero.threshold.solution</code>; "max.diff", the maximum difference
in the estimates between two successive iterations; "nqp", the
number of (inner loop) active-set iterations taken to solve the
quadratic subproblem; "nls", the number of iterations in the
backtracking line search.</p></dd>
</dl>
    
    <h2 class="hasAnchor" id="references"><a class="anchor" href="#references"></a>References</h2>

    <p>Y. Kim, P. Carbonetto, M. Stephens and M. Anitescu (2018). A fast
algorithm for maximum likelihood estimation of mixture proportions
using sequential quadratic programming. arXiv:1806.01412
<a href='https://arxiv.org/abs/1806.01412'>https://arxiv.org/abs/1806.01412</a>.</p>
    
    <h2 class="hasAnchor" id="see-also"><a class="anchor" href="#see-also"></a>See also</h2>

    <p><code>mixobjective</code>, <code>mixkwdual</code></p>
    

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='fu'>set.seed</span>(<span class='fl'>1</span>)
<span class='no'>n</span> <span class='kw'>&lt;-</span> <span class='fl'>1e5</span>
<span class='no'>m</span> <span class='kw'>&lt;-</span> <span class='fl'>10</span>
<span class='no'>w</span> <span class='kw'>&lt;-</span> <span class='fu'>rep</span>(<span class='fl'>1</span>,<span class='no'>n</span>)/<span class='no'>n</span>
<span class='no'>L</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='simulatemixdata.html'>simulatemixdata</a></span>(<span class='no'>n</span>,<span class='no'>m</span>)$<span class='no'>L</span>
<span class='no'>out.mixsqp</span> <span class='kw'>&lt;-</span> <span class='fu'>mixsqp</span>(<span class='no'>L</span>,<span class='no'>w</span>)</div><div class='output co'>#&gt; Running mix-SQP algorithm 0.1-73 on 100000 x 10 matrix
#&gt; convergence tol. (SQP):     1.0e-08
#&gt; conv. tol. (active-set):    1.0e-10
#&gt; zero threshold (solution):  1.0e-06
#&gt; zero thresh. (search dir.): 1.0e-08
#&gt; max. iter (SQP):            1000
#&gt; max. iter (active-set):     100
#&gt; iter    objective max(rdual) nnz max.diff nqp nls
#&gt;    1 +7.72664e-01 +2.756e-01  10       NA  NA  NA
#&gt;    2 +6.53047e-01 +4.736e+00   5 3.38e-01  13   1
#&gt;    3 +6.04839e-01 +2.156e+00   5 4.67e-02   8   1
#&gt;    4 +5.99876e-01 +9.136e-01   5 8.23e-03   2   1
#&gt;    5 +5.99756e-01 +2.970e-01   5 1.60e-03   2   1
#&gt;    6 +5.99697e-01 +1.645e-01   5 4.96e-03   2   1
#&gt;    7 +5.99515e-01 +7.147e-02   5 9.18e-03   2   1
#&gt;    8 +5.99190e-01 +1.949e-02   5 8.83e-03   2   1
#&gt;    9 +5.98988e-01 +1.944e-03   5 3.62e-03   2   1
#&gt;   10 +5.98959e-01 +2.152e-05   5 3.94e-04   2   1
#&gt;   11 +5.98959e-01 -1.537e-08   5 4.32e-06   2   1
#&gt; Convergence criteria met---optimal solution found.</div><div class='input'><span class='no'>f</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='mixobjective.html'>mixobjective</a></span>(<span class='no'>L</span>,<span class='no'>out.mixsqp</span>$<span class='no'>x</span>,<span class='no'>w</span>)
<span class='fu'>print</span>(<span class='no'>f</span>,<span class='kw'>digits</span> <span class='kw'>=</span> <span class='fl'>16</span>)</div><div class='output co'>#&gt; [1] 0.5989590363728408</div><div class='input'>
# We can also compare this result with solution found from an 
# interior-point approach called via the "KWDual" function from the 
# REBayes package. (This requires installation of the MOSEK 
# optimization library as well as the REBayes package, so we have
# made this step optional.)
</div><span class='co'># NOT RUN {</span>
<span class='no'>out.kwdual</span> <span class='kw'>&lt;-</span> <span class='fu'><a href='mixkwdual.html'>mixkwdual</a></span>(<span class='no'>L</span>,<span class='no'>w</span>)
<span class='fu'>print</span>(<span class='fu'><a href='mixobjective.html'>mixobjective</a></span>(<span class='no'>L</span>,<span class='no'>out.kwdual</span>$<span class='no'>x</span>,<span class='no'>w</span>),<span class='kw'>digits</span> <span class='kw'>=</span> <span class='fl'>16</span>)
<span class='co'># }</span></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      <li><a href="#arguments">Arguments</a></li>
      
      <li><a href="#value">Value</a></li>

      <li><a href="#details">Details</a></li>

      <li><a href="#references">References</a></li>

      <li><a href="#see-also">See also</a></li>
      
      <li><a href="#examples">Examples</a></li>
    </ul>

  </div>
</div>

      <footer>
      <div class="copyright">
  <p>Developed by Youngseok Kim, Peter Carbonetto, Mihai Anitescu, Matthew Stephens.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
   </div>

  </body>
</html>
