<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Solution to "Mixture Optimization" Problem — mixSQP • mixSQP</title>

<!-- jquery -->
<script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<!-- Font Awesome icons -->
<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script>
<script src="../pkgdown.js"></script>
  
  
<meta property="og:title" content="Solution to "Mixture Optimization" Problem — mixSQP" />

<meta property="og:description" content="mixSQP and mixKWDual can be used to
  compute maximum-likelihood estimates of mixture proportions in a
  (finite) mixture model, or it can be used more generally to solve
  the a constrained, convex optimization problem of the form given
  below (see "Details"). mixSQP uses a Sequential Quadatric
  Programming (SQP) approach to solve a slightly modified primal
  formulation of the convex optimization problem. See "References"
  for more details about the SQP algorithm and the motivation behind
  it. mixKWDual uses the MOSEK interior-point (IP) algorithm
  to solve a dual formulation of the original problem; see
  KWDual for details." />
<meta name="twitter:card" content="summary" />
<!-- mathjax -->
<script src='https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->


  </head>

  <body>
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">mixSQP</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">Home</a>
</li>
<li>
  <a href="../articles/index.html">Vignettes</a>
</li>
<li>
  <a href="../reference/index.html">Functions</a>
</li>
      </ul>
      
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/youngseok-kim/mixsqp">Source</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      
      </header>

      <div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Solution to "Mixture Optimization" Problem</h1>
    </div>

    
    <p><code>mixSQP</code> and <code>mixKWDual</code> can be used to
  compute maximum-likelihood estimates of mixture proportions in a
  (finite) mixture model, or it can be used more generally to solve
  the a constrained, convex optimization problem of the form given
  below (see "Details"). <code>mixSQP</code> uses a Sequential Quadatric
  Programming (SQP) approach to solve a slightly modified primal
  formulation of the convex optimization problem. See "References"
  for more details about the SQP algorithm and the motivation behind
  it. <code>mixKWDual</code> uses the MOSEK interior-point (IP) algorithm
  to solve a dual formulation of the original problem; see
  <code><a href='http://www.rdocumentation.org/packages/REBayes/topics/KWDual'>KWDual</a></code> for details.</p>
    

    <pre class="usage"><span class='fu'>mixSQP</span>(<span class='no'>L</span>, <span class='kw'>w</span> <span class='kw'>=</span> <span class='fu'>rep</span>(<span class='fl'>1</span>, <span class='fu'>nrow</span>(<span class='no'>L</span>)), <span class='kw'>x0</span> <span class='kw'>=</span> <span class='fu'>rep</span>(<span class='fl'>1</span>, <span class='fu'>ncol</span>(<span class='no'>L</span>)),
  <span class='kw'>convtol.sqp</span> <span class='kw'>=</span> <span class='fl'>1e-08</span>, <span class='kw'>convtol.activeset</span> <span class='kw'>=</span> <span class='fl'>1e-10</span>,
  <span class='kw'>zero.threshold</span> <span class='kw'>=</span> <span class='fl'>1e-06</span>, <span class='kw'>eps</span> <span class='kw'>=</span> <span class='no'>.Machine</span>$<span class='no'>double.eps</span>, <span class='kw'>delta</span> <span class='kw'>=</span> <span class='fl'>1e-10</span>,
  <span class='kw'>maxiter.sqp</span> <span class='kw'>=</span> <span class='fl'>1000</span>, <span class='kw'>maxiter.activeset</span> <span class='kw'>=</span> <span class='fl'>100</span>, <span class='kw'>verbose</span> <span class='kw'>=</span> <span class='fl'>TRUE</span>)

<span class='fu'>mixobjective</span>(<span class='no'>L</span>, <span class='no'>x</span>, <span class='kw'>w</span> <span class='kw'>=</span> <span class='fu'>rep</span>(<span class='fl'>1</span>, <span class='fu'>nrow</span>(<span class='no'>L</span>)))

<span class='fu'>mixKWDual</span>(<span class='no'>L</span>, <span class='kw'>w</span> <span class='kw'>=</span> <span class='fu'>rep</span>(<span class='fl'>1</span>, <span class='fu'>nrow</span>(<span class='no'>L</span>)), <span class='no'>...</span>)</pre>
    
    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a> Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>L</th>
      <td><p>Matrix specifying the optimization problem to be solved.
In the context of mixture-model fitting, <code>L[j,k]</code> should be
the response of the kth mixture component density at the jth data
point. <code>L</code> should be a numeric matrix with at least two
columns, in which all its entries are positive finite (and not
missing). For large matrices, it is preferrable that the matrix is
stored in double-precision; see <code>storage.mode</code>.</p></td>
    </tr>
    <tr>
      <th>w</th>
      <td><p>An optional numeric vector, with one entry for each row of
<code>L</code>, specifying the "weights" associated with the rows of
<code>L</code>. All weights must be finite, non-negative and not
missing. The weights should sum to 1; if they are not, they will
automatically be normalized to sum to 1. By default, all weights
are the same.</p></td>
    </tr>
    <tr>
      <th>x0</th>
      <td><p>An optional numeric vector providing an initial estimate
of the solution to the optimization problem. It should contain only
finite, non-missing, non-negative values, and the entries should
sum to 1; if it is not, the vector is automatically normalized to
sum to 1. By default, <code>x0</code> is the vector with all equal values.</p></td>
    </tr>
    <tr>
      <th>convtol.sqp</th>
      <td><p>A small, non-negative number specifying the
convergence tolerance for SQP algorithm; convergence is reached
when the maximum dual residual in the Karush-Kuhn-Tucker optimality
conditions is less than or equal to <code>convtol.sqp</code>. Smaller
values will result in more stringent convergence criteria and more
accurate solutions, at the expense of greater computation time.</p></td>
    </tr>
    <tr>
      <th>convtol.activeset</th>
      <td><p>Small, non-negative number specifying the
convergence tolerance for the active-set step. Smaller values will
result in higher quality search directions for the SQP algorithm
but possibly a greater per-iteration computational cost.</p></td>
    </tr>
    <tr>
      <th>zero.threshold</th>
      <td><p>A small, non-negative number used to
determine the "active set"; that is, it determines which entries of
the solution are exactly zero. Any entries that are less than or
equal to <code>zero.threshold</code> are considered to be exactly
zero. Larger values of <code>zero.threshold</code> may lead to speedups
for matrices with many columns, at the (slight) risk of prematurely
zeroing some co-ordinates.</p></td>
    </tr>
    <tr>
      <th>eps</th>
      <td><p>A small, non-negative number added to the terms inside the
logarithms to sidestep computing logarithms of zero. This prevents
numerical problems at the cost of introducing a small inaccuracy in
the solution. Increasing this number may lead to faster convergence
but possibly a less accurate solution.</p></td>
    </tr>
    <tr>
      <th>delta</th>
      <td><p>A small, non-negative number added to the diagonal of the
Hessian to improve numerical stability (and possibly the speed)
when computing the search directions in the active-set step.</p></td>
    </tr>
    <tr>
      <th>maxiter.sqp</th>
      <td><p>Maximum number of SQP iterations to run before
reporting a convergence failure; that is, the maximum number of
quadratic subproblems that will be solved by the active-set method.</p></td>
    </tr>
    <tr>
      <th>maxiter.activeset</th>
      <td><p>Maximum number of active-set iterations
taken to solve each of the quadratic subproblems.</p></td>
    </tr>
    <tr>
      <th>verbose</th>
      <td><p>If <code>verbose = TRUE</code>, the algorithm's progress
and a summary of the optimization settings are printed to the
console. The algorithm's progress is displayed in a table with one
row per SQP (outer loop) iteration, and with the following columns:
"iter", the (outer loop) SQP iteration; "objective", the value of
the (unmodified) objective function at the current estimate of the
solution; "max.diff", the maximum difference in the estimates
between two successive iterations; "max(rdual)", the maximum "dual
residual" in the Karush-Kuhn-Tucker (KKT) conditions, which is used
to monitor convergence (see <code>convtol.sqp</code>); "nnz", the number
of non-zero co-ordinates in the current estimate, as determined by
<code>zero.threshold</code>, "nqp", the number of (inner loop) active-set
iterations taken to solve the quadratic subproblem; "nls", the
number of iterations in the backtracking line search.</p></td>
    </tr>
    <tr>
      <th>x</th>
      <td><p>The point at which the objective is evaluated in
<code>mixobjective</code>; see argument <code>x0</code> for details.</p></td>
    </tr>
    <tr>
      <th>...</th>
      <td><p>Additional arguments passed to <code><a href='http://www.rdocumentation.org/packages/REBayes/topics/KWDual'>KWDual</a></code>.</p></td>
    </tr>
    </table>
    
    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p><code>mixobjective</code> returns the value of the (unmodified)
objective at <code>x</code>.

<code>mixKWDual</code> returns a list object with the following
list elements:</p>
<dt>x</dt><dd><p>The estimated solution to the convex optimization problem.</p></dd>

<dt>value</dt><dd><p>The value of the (unmodified) objective function at
  <code>x</code>.</p></dd>

<dt>status</dt><dd><p>The return status from MOSEK.</p></dd>

For more information on this output, see
<a href='http://www.rdocumentation.org/packages/REBayes/topics/KWDual'>KWDual</a> and <a href='http://www.rdocumentation.org/packages/Rmosek/topics/mosek'>mosek</a>.

mixSQP returns a list object with the following list elements:

<dt>x</dt><dd><p>The estimated solution to the convex optimization problem.</p></dd>

<dt>value</dt><dd><p>The value of the (unmodified) objective function at
  <code>x</code>.</p></dd>

<dt>status</dt><dd><p>A character string giving the status of the algorithm
  upon termination.</p></dd>

<dt>data</dt><dd><p>A data frame containing more detailed information about
  the algorithm's progress. The data frame has one row per SQP
  iteration. For an explanation of the columns, see the description
  of the <code>verbose</code> argument above. Missing values (NA's) in the
  last row indicate that these quantities were not computed because
  convergence was reached before computing them. Also note that the
  association of these quantities is slightly different than the
  console output when <code>verbose = TRUE</code> as the console output
  shows some quantities that were computed after the convergence
  check in the previous iteration. The last entries of max.diff, nqp
  and nls may not have been # assigned if the SQP algorithm converged
  successfully (as indicated # by negative values), in which case we
  should more appropriately # assign them missing values (NA).</p></dd>

    
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>Here is a mathematical description of the constrained,
  convex optimization problem solved by <code>mixSQP</code> and
  <code>mixKWDual</code>. Let \(L\) be a matrix with \(n\) rows and
  \(m\) rows containing only non-negative entries, and let \(w =
  (w_1, \ldots, w_n)\) be a matrix of non-negative "weights" that sum
  to 1. mixSQP computes the value of vector \(x = (x_1, \ldots,
  x_m)\) minimizing the following objective function, $$f(x) =
  -1/n \sum_{j=1}^n w_j log (\sum_{k=1}^m L_{jk} x_k),$$ subject to
  the constraint that \(x\) lie within the simplex; that is, all
  entries of \(x\) are non-negative, and the sum of these entries
  is equal to 1. The Expectation Maximization (EM) algorithm can be
  used to solve this optimization problem, but it is intolerably slow
  in many interesting cases.</p>
<p><code>mixSQP</code> is implemented using the Armadillo C++ linear
  algebra library, which can automatically take advantage of
  multithreaded matrix computations to speed up <code>mixSQP</code> for
  large <code>L</code> matrices, but only when R has been configured with a
  multithreaded BLAS/LAPACK library (e.g., OpenBLAS).</p>
    
    <h2 class="hasAnchor" id="references"><a class="anchor" href="#references"></a>References</h2>

    <p>Y. Kim, P. Carbonetto, M. Stephens and M. Anitescu (2018). A fast
  algorithm for maximum likelihood estimation of mixture proportions
  using sequential quadratic programming. arXiv:1806.01412
  <a href='https://arxiv.org/abs/1806.01412'>https://arxiv.org/abs/1806.01412</a>.</p>
    
    <h2 class="hasAnchor" id="see-also"><a class="anchor" href="#see-also"></a>See also</h2>

    <p><code><a href='http://www.rdocumentation.org/packages/REBayes/topics/KWDual'>KWDual</a></code></p>
    

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='fu'>set.seed</span>(<span class='fl'>1</span>)
<span class='no'>n</span>  <span class='kw'>&lt;-</span> <span class='fl'>1e5</span>
<span class='no'>m</span>  <span class='kw'>&lt;-</span> <span class='fl'>10</span>
<span class='no'>w</span>  <span class='kw'>&lt;-</span> <span class='fu'>rep</span>(<span class='fl'>1</span>,<span class='no'>n</span>)/<span class='no'>n</span>
<span class='no'>L</span>  <span class='kw'>&lt;-</span> <span class='fu'><a href='simulatemixdata.html'>simulatemixdata</a></span>(<span class='no'>n</span>,<span class='no'>m</span>)$<span class='no'>L</span>
<span class='no'>out.mixsqp</span> <span class='kw'>&lt;-</span> <span class='fu'>mixSQP</span>(<span class='no'>L</span>,<span class='no'>w</span>)</div><div class='output co'>#&gt; Running mix-SQP 0.1-36 on 100000 x 10 matrix
#&gt; convergence tol. (SQP):  1.0e-08
#&gt; conv. tol. (active-set): 1.0e-10
#&gt; max. iter (SQP):         1000
#&gt; max. iter (active-set):  100
#&gt; zero threshold:          1.0e-06
#&gt; iter    objective max.diff max(rdual) nnz nqp nls
#&gt;    1 +7.72664e-01       NA +2.756e-01  10  NA  NA
#&gt;    2 +6.53047e-01 3.38e-01 +4.747e+00   5  13   1
#&gt;    3 +6.04839e-01 4.67e-02 +2.163e+00   5   8   1
#&gt;    4 +5.99876e-01 8.23e-03 +9.175e-01   5   2   1
#&gt;    5 +5.99756e-01 1.59e-03 +2.977e-01   5   2   1
#&gt;    6 +5.99697e-01 4.94e-03 +1.651e-01   5   2   1
#&gt;    7 +5.99516e-01 9.17e-03 +7.180e-02   5   2   1
#&gt;    8 +5.99192e-01 8.85e-03 +1.964e-02   5   2   1
#&gt;    9 +5.98988e-01 3.64e-03 +1.972e-03   5   2   1
#&gt;   10 +5.98959e-01 4.00e-04 +2.234e-05   5   2   1
#&gt;   11 +5.98959e-01 4.45e-06 +2.888e-09   5   2   1
#&gt; Convergence criteria met---optimal solution found.</div><div class='input'><span class='no'>out.kwdual</span> <span class='kw'>&lt;-</span> <span class='fu'>mixKWDual</span>(<span class='no'>L</span>,<span class='no'>w</span>)
<span class='fu'>print</span>(<span class='fu'>mixobjective</span>(<span class='no'>L</span>,<span class='no'>out.mixsqp</span>$<span class='no'>x</span>,<span class='no'>w</span>),<span class='kw'>digits</span> <span class='kw'>=</span> <span class='fl'>16</span>)</div><div class='output co'>#&gt; [1] 0.5989590363728408</div><div class='input'><span class='fu'>print</span>(<span class='fu'>mixobjective</span>(<span class='no'>L</span>,<span class='no'>out.kwdual</span>$<span class='no'>x</span>,<span class='no'>w</span>),<span class='kw'>digits</span> <span class='kw'>=</span> <span class='fl'>16</span>)</div><div class='output co'>#&gt; [1] 0.5989590363746571</div><div class='input'>
</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
    <h2>Contents</h2>
    <ul class="nav nav-pills nav-stacked">
      <li><a href="#arguments">Arguments</a></li>
      
      <li><a href="#value">Value</a></li>

      <li><a href="#details">Details</a></li>

      <li><a href="#references">References</a></li>

      <li><a href="#see-also">See also</a></li>
      
      <li><a href="#examples">Examples</a></li>
    </ul>

  </div>
</div>

      <footer>
      <div class="copyright">
  <p>Developed by Youngseok Kim, Peter Carbonetto, Mihai Anitescu, Matthew Stephens.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
   </div>

  </body>
</html>
