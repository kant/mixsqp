% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kwdual.R, R/mixobjective.R, R/mixsqp.R
\name{mixSQP}
\alias{mixSQP}
\alias{mixKWDual}
\alias{mixobjective}
\title{mixSQP}
\usage{
mixKWDual(L, w = rep(1, nrow(L)), ...)

mixobjective(L, x, w = rep(1, nrow(L)))

mixSQP(L, w = rep(1, nrow(L)), x0 = rep(1, ncol(L)),
  convtol.sqp = 1e-08, zero.threshold = 1e-06,
  eps = .Machine$double.eps, delta = 0.01 * convtol.sqp,
  maxiter.sqp = 1000, maxiter.activeset = 100, verbose = TRUE)
}
\arguments{
\item{L}{Matrix specifying the optimization problem to be solved.
In the context of mixture-model fitting, \code{L[j,k]} should be
the response of the kth mixture component density at the jth data
point. \code{L} should be a numeric matrix with at least two
columns, in which all its entries are positive finite (and not
missing). For large matrices, it is preferrable that the matrix is
stored in double-precision; see \code{\link{storage.mode}}.}

\item{w}{An optional numeric vector, with one entry for each row of
\code{L}, specifying the "weights" associated with the rows of
\code{L}. All weights must be finite, positive and not missing. The
weights should sum to 1; if they are not, they will automatically
 be normalized to sum to 1. By default, all weights are the same.}

\item{...}{Additional arguments passed to \code{\link[REBayes]{KWDual}}.}

\item{x0}{An optional numeric vector providing an initial estimate
of the solution to the optimization problem. It should contain only
finite, non-missing, non-negative values, and the entries should
sum to 1; if it is not, the vector is automatically normalized to
sum to 1. By default, \code{x0} is the vector with all equal values.}

\item{convtol.sqp}{A convergence tolerance used for algorithm's
convergence criterion.}

\item{zero.threshold}{A small, non-negative number used to
determine the "active set"; that is, it determines which entries of
the solution are exactly zero. Any entries that are less than or
equal to \code{zero.threshold} are considered to be exactly
zero. Larger values of \code{zero.threshold} may lead to speedups
for matrices with many columns, at the (slight) risk of prematurely
zeroing some co-ordinates.}

\item{eps}{A small constant to safeguard from a numerical issue.}

\item{delta}{A small constant added to diagonal of Hessian to
improve numerical stability of search directions in active-set
method.}

\item{maxiter.sqp}{Maximum number of SQP iterations; that is, the
maximum number of quadratic subproblems that will be solved by the
active-set method.}

\item{maxiter.activeset}{Maximum number of active-set iterations
taken to solve each of the quadratic subproblems.}

\item{verbose}{If \code{verbose = TRUE}, the algorithm's progress
and a summary of the optimization settings are printed to the
console. The algorithm's progress is displayed in a table with the
following columns: "iter", the (outer loop) SQP iteration;
"objective", the value of the (unmodified) objective function at
the current estimate of the solution; "max(rdual)", the maximum
"dual residual" in the Karush-Kuhn-Tucker (KKT) conditions, which
is used to monitor convergence (see \code{convtol.sqp}); "nnz", the
number of non-zero co-ordinates in the current estimate, as
determined by \code{zero.threshold}, "nqp", the number of (inner
loop) active-set iterations taken to solve the quadratic
subproblem; "nls", the number of iterations in the backtracking
line search.}
}
\value{
Returns a solution x (in the current version). Also returns
  the algorithm convergence status.
}
\description{
mixSQP solves a convex optimization problem in
  https://arxiv.org/abs/1806.01412.
  It implements a sequential quadratic programming with
  active-set subproblem solvers.
}
\details{
When L is a (n) by (m) matrix of nonnegative entries,
mixSQP maximizes the following objective function \deqn{f(x) =
\sum_j w_j \log (\sum_k L_jk x_k)} subject to the (unit)
probability simplex constraint \deqn{\sum_k x_k = 1, x_k \ge 0}
Without loss of generality \eqn{\sum_j w_j = 1} is required.
}
\examples{
set.seed(1)
n  <- 1e5
m  <- 10
w  <- rep(1,n)/n
L  <- simulatemixdata(n,m)$L
out.mixsqp <- mixSQP(L,w)
out.kwdual <- mixKWDual(L,w)
print(mixobjective(L,out.mixsqp$x,w),digits = 16)
print(mixobjective(L,out.kwdual$x,w),digits = 16)

}
